package io.availe.helpers

import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.symbol.Modifier

data class KSTypeInfo(
    val qualifiedName: String,
    val arguments: List<KSTypeInfo>,
    val isNullable: Boolean,
    val isEnum: Boolean,
    val isValueClass: Boolean,
    val isDataClass: Boolean,
    val requiresContextual: Boolean
) {
    val leafType: KSTypeInfo
        get() = if (arguments.isEmpty()) this else arguments.last().leafType

    companion object {
        private const val JVM_INLINE_ANNOTATION_FQN = "kotlin.jvm.JvmInline"

        fun from(ksType: KSType, environment: SymbolProcessorEnvironment, resolver: Resolver): KSTypeInfo {
            if (ksType.isError) {
                val typeName = ksType.declaration.simpleName.asString()
                val parentProperty =
                    (ksType.declaration.parentDeclaration as? KSClassDeclaration)?.qualifiedName?.asString()
                val errorMessage = "KReplica KSP Error: Could not resolve type '$typeName'." +
                        if (parentProperty != null) " It is a property on '$parentProperty'." else "" +
                                " This often happens if the type is generated by another module." +
                                " Ensure that sources generated in upstream modules are correctly shared with downstream KSP tasks."
                throw IllegalStateException(errorMessage)
            }

            val decl = ksType.declaration as KSClassDeclaration
            val qualified = decl.qualifiedName?.asString()
                ?: throw IllegalStateException("Failed to get qualified name for declaration '${decl.simpleName.asString()}'")

            val args =
                ksType.arguments.mapNotNull { it.type?.resolve()?.let { type -> from(type, environment, resolver) } }
            val nullable = ksType.isMarkedNullable
            val isEnum = decl.classKind == ClassKind.ENUM_CLASS
            val isData = decl.modifiers.contains(Modifier.DATA)
            val needsContextual = needsContextualSerializer(ksType, resolver)

            val isValueByModifier = decl.modifiers.contains(Modifier.VALUE)
            val isValueByAnnotation = decl.annotations.any {
                it.annotationType.resolve().declaration.qualifiedName?.asString() == JVM_INLINE_ANNOTATION_FQN
            }
            val isValue = isValueByModifier || isValueByAnnotation

            environment.logger.logging("KSTypeInfo.from qualifiedName=$qualified isEnum=$isEnum isValueClass=$isValue isDataClass=$isData")
            return KSTypeInfo(qualified, args, nullable, isEnum, isValue, isData, needsContextual)
        }
    }
}

fun KSTypeInfo.toModelTypeInfo(
    customSerializerFqName: String? = null,
    forceContextual: Boolean = false
): io.availe.models.TypeInfo =
    io.availe.models.TypeInfo(
        qualifiedName = qualifiedName,
        arguments = arguments.map { it.toModelTypeInfo() },
        isNullable = isNullable,
        isEnum = isEnum,
        isValueClass = isValueClass,
        isDataClass = isDataClass,
        requiresContextual = requiresContextual,
        customSerializerFqName = customSerializerFqName,
        forceContextual = forceContextual
    )